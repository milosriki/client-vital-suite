import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
import { unifiedAI } from "../_shared/unified-ai-client.ts";
import { verifyAuth } from "../_shared/auth-middleware.ts";
import {
  apiSuccess,
  apiError,
  apiCorsPreFlight,
} from "../_shared/api-response.ts";

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers":
    "authorization, x-client-info, apikey, content-type",
};

serve(async (req) => {
  if (req.method === "OPTIONS") {
    return apiCorsPreFlight();
  }

  try {
    const supabase = createClient(
      Deno.env.get("SUPABASE_URL")!,
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!,
    );

    console.log("ðŸ§  Starting AI Learning Loop...");

    // 1. Fetch unapplied feedback
    const { data: feedbackItems, error: fetchError } = await supabase
      .from("ai_feedback_learning")
      .select("*, proactive_insights(*), intervention_log(*)")
      .eq("applied_to_model", false)
      .limit(50);

    if (fetchError) throw fetchError;

    if (!feedbackItems || feedbackItems.length === 0) {
      return apiSuccess({ message: "No new feedback to process" });
    }

    console.log(`Processing ${feedbackItems.length} feedback items...`);
    let rulesUpdated = 0;
    let patternsLearned = 0;

    for (const item of feedbackItems) {
      // Logic A: Positive Feedback (Reinforcement)
      if (item.feedback_score && item.feedback_score >= 4) {
        // Find if this was generated by a rule
        if (item.insight_id || item.intervention_id) {
          // Heuristic: If it was a proactive insight, boost the rule confidence
          // Note: In a real system we'd link insight -> rule_id.
          // For now, we'll increment a general 'positive_feedback' counter or specific pattern if we can match it.
          // Since we don't have direct linkage yet, we'll skip direct rule update and just log it for now
          // unless we find a matching rule.
        }
      }

      // Logic B: Negative Feedback + Correction (New Rule Generation)
      if (item.user_correction && item.user_correction.length > 5) {
        console.log(`ðŸ“ Learning from correction: "${item.user_correction}"`);

        // Use Gemini to extract a generalized rule
        const context = item.context_data
          ? JSON.stringify(item.context_data)
          : "No context";
        const prompt = `
          You are an AI System Architect. A user corrected an AI decision. 
          Extract a generic "IF -> THEN" business rule from this correction.

          CONTEXT: ${context}
          ORIGINAL AI OUTPUT: ${item.original_recommendation}
          USER CORRECTION: ${item.user_correction}

          OUTPUT JSON ONLY:
          {
            "condition_pattern": { "field": "value_operator" },
            "action_pattern": { "action": "description" },
            "confidence": 0.8,
            "explanation": "Why this rule exists"
          }
        `;

        try {
          const aiResponse = await unifiedAI.chat(
            [{ role: "user", content: prompt }],
            { jsonMode: true },
          );

          const ruleData = JSON.parse(
            aiResponse.content.replace(/```json|```/g, ""),
          );

          if (ruleData.condition_pattern) {
            await supabase.from("ai_learning_rules").insert({
              rule_type: "learned_correction",
              condition_pattern: ruleData.condition_pattern,
              action_pattern: ruleData.action_pattern,
              confidence_score: ruleData.confidence || 0.7,
              source: "user_feedback_loop",
              is_active: true,
            });
            patternsLearned++;
          }
        } catch (err) {
          console.error("Failed to extract rule:", err);
        }
      }

      // Mark as processed
      await supabase
        .from("ai_feedback_learning")
        .update({
          applied_to_model: true,
          applied_at: new Date().toISOString(),
        })
        .eq("id", item.id);
    }

    return apiSuccess({
      success: true,
      processed: feedbackItems.length,
      patterns_learned: patternsLearned,
    });
  } catch (error: unknown) {
    console.error("Learning Loop Error:", error);
    const message = error instanceof Error ? error.message : "Unknown error";
    return apiError("INTERNAL_ERROR", message, 500);
  }
});
